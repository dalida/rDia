---
title: |
  | diateam
  | SCAD\@COPS
  | A Hybrid Network Intrusion Detection System
author: "Lisa MALIPHOL"
fontsize: 11pt
geometry: margin=1in
output:
  pdf_document:
    toc_depth: 2
    number_sections: true
    keep_tex: yes
  word_document: default
bibliography: thesis.bib
csl: ieee-with-url.csl
---

```{r, echo=FALSE, message=FALSE, warning=FALSE}
require(TRSbook)
require(data.table)
require(igraph)
require(ggplot2)
require(gplots)
require(lattice)
require(dplyr)
require(plyr)
require(reshape2)
require(RColorBrewer)
require(png)
require(grid)
require(gridExtra)
library(rjson)
library(knitr)
```

```{r, message=FALSE, warning=FALSE, echo=FALSE}

homeDir <- "/Users/lstilo/rDia/"
#homeDir <- "/home/lisa/rDia/"

# Load data from save(sewTCPConvDT, sewEndPtsDT, file="sewConvEnd.Rda")
load(paste(homeDir, "sewConvEnd.Rda", sep=''))

# Load data from save(sewModbusDT file="sew.Rda")
#load(paste(homeDir, "sew.Rda", sep=''))

# Load data from save(mergedSewDT, file="sewMerged.Rda")
load(paste(homeDir, "sewMerged.Rda", sep=''))

# Load data from save(normalTCPConvDT, normalEndPtsDT, file="normalConvEnd.Rda")
#load(paste(homeDir, "normalConvEnd.Rda", sep=''))

# Load data from save(normalModbusDT file="normal.Rda")
load(paste(homeDir, "normal.Rda", sep=''))

# Load data from save(normalMergedDT, file="normalMerged.Rda")
load(paste(homeDir, "normalMerged.Rda", sep=''))
```


```{r, echo=FALSE, fig.height=8, fig.width=8}
img <- readPNG(paste(homeDir, "imgs/wordle.png", sep=''))
grid.raster(img)
```


\thispagestyle{empty}

\newpage
\thispagestyle{empty}
\mbox{}

\clearpage
\pagenumbering{roman}

\begin{center}

\vspace{30mm}

{\Huge diateam}\\
\bigskip
{\Huge SCAD@COPS}\\
\bigskip
\bigskip
{\Huge A Hybrid}\\
{\Huge Network Intrusion Detection System}\\
\vspace{15mm}
{\Large by}\\
\vspace{10mm}
{\huge Lisa MALIPHOL}\\

\vspace{25mm}

\textit{A thesis submitted in partial satisfaction of the}\\
\medskip
\textit{requirements for the diploma of the}\\
\medskip
\textit{Masters of Science}\\
\medskip
\textit{in}\\
\medskip
\textit{Computer Science and Decision Systems}\\
\medskip
\textit{in the}\\
\medskip
\textit{Grande École}\\
\medskip
\textbf{\textit{\Large Télécom Bretagne}}\\

\vspace{15mm}

Corporate Advisor:\\
\smallskip
Guillaume Prigent\\
\bigskip
\medskip
Academic Advisors:\\
\smallskip
Professor Yannis Haralambous\\
Professor Sandrine Vaton\\

\vspace{15mm}

\textit{September 2015}\\
\medskip
\textit{Plouzané, FRANCE}\\

\end{center}

\thispagestyle{empty}
\newpage
\mbox{}
\thispagestyle{empty}

\newpage

\begin{center}

\vspace{30mm}

{\Huge diateam}\\
\bigskip
{\Huge SCAD@COPS}\\
\bigskip
\bigskip
{\Huge Un système hybride de détection}\\
{\Huge d’intrusion de réseau }\\

\vspace{30mm}
{\huge Lisa MALIPHOL}\\

\vspace{75mm}
\textit{septembre 2015}\\
\medskip
\textit{Plouzané, FRANCE}\\

\end{center}

\thispagestyle{empty}
\newpage
\mbox{}
\thispagestyle{empty}

\newpage

# Acknowledgements {-}

\newpage
\mbox{}
\thispagestyle{empty}

\clearpage

# Abstract {-}

Large scale, industrial processes and infrastructure, such as in the energy, or manufacturing sectors, may span across multiple, large, remote and disconnected geographical areas and are comprised of multiple devices, controllers and sensors. They are managed, monitored and controlled by computer systems called Supervisory Control and Data Acquisition (SCADA) systems. Previously, these systems resided on their own networks and used proprietary protocols and software, and therefore through obscurity and isolation were moderately immune to outside threats. Over time, with the advancement of technologies, such as in computing systems and networking, and increased interconnectivity to traditional IT systems they have become susceptible and more vulnerable to cyber attacks.

In order to address this issue, Network Intrusion Detection Systems (NIDS) have been put in place in SCADA environments to monitor and survey the network and systems to identify suspicious, or anomalous activities and events. Signature-based NIDSs are an established method previously utilized, although anomaly-based NIDS have grown in interest. In contrast to signature-based methods, which are very capable and more accurate in identifying known attacks, anomaly-based NIDSs are appealing as they can detect novel, never seen before attacks. Anomaly-based approaches may be based on statistical, data mining, or machine learning methods.

diateam has proposed a hybrid network intrusion detection system that not only provides measures in better securing the device itself, but more importantly, combines both signature- and anomaly-based techniques. The inception of the hybrid NIDS is the proof of concept that is presented in this paper. This study also incorporates another diateam product, the Virtual Scada Box, as the testbed for conducting analysis and evaluation as real-world network attack data is generally restricted.

\bigskip
\bigskip
\textbf{Keywords: } NIDS, Anomaly-based Network Intrusion Detection, Industrial Control Systems, SCADA Systems, MODBUS/TCP

\newpage
\mbox{}
\thispagestyle{empty}

\clearpage

# Résumé {-}

Les sites industriels importants, telle qu’on en trouve dans le secteur de l'énergie, sont composés de multiples centres de productions pouvant être éloignés géographiquement les uns des autres. Ces différents sites sont reliés par de nombreux canaux de communication par lesquels passent des informations de contrôle et de commande de la production. L’ensemble de ce réseau est communément appelé par l’acronyme anglais SCADA “Supervisory Control and Data Acquisition” qui peut être traduit en français par: système de contrôle et d’acquisition de donnée.

Auparavant, ces systèmes résidaient sur leur propres réseaux et utilisaient des protocoles et logicielles propriétaires. Leur isolation du réseau ainsi que la méconnaissance de leur protocoles les rendait relativement à l'abri de menaces extérieures. Au fil du temps, avec l’évolution des technologies, notamment des systèmes informatiques et des réseaux , ainsi que l'augmentation de l'interconnectivité avec des systèmes informatiques traditionnels, les ont rendu sensibles et vulnérables face aux attaques informatiques.

Afin de faire face à ces enjeux, les systèmes de détection d'intrusion réseau (NIDS) ont été mis en place dans des environnements SCADA pour surveiller les réseaux et les systèmes.  Cela afin d'identifier les activités et les événements suspects ou anormaux. Actuellement la majorité des NIDS se basent sur une liste de signatures, mais de plus en plus on s’orientent vers des mécanismes de détection d’anomalies. Contrairement aux systèmes basées sur des signatures qui sont très efficace et plus précis dans l'identification des attaques connues, les NIDS basées sur des anomalies sont attrayant car ils peuvent détecter des nouvelles attaques qui n'ont jamais été vu auparavant. Les approches basées sur des anomalies s’appuient sur des méthodes statistiques, de fouilles de données, ou de machine learning.

diateam a proposé an système hybride de détection d'intrusion qui fournit non seulement des mesures pour protéger le dispositif lui-même, mais surtout, combine les deux techniques basées sur des signatures et des anomalies. C’est ce NIDS hybride, développé comme une  preuve de concept, qui sera présenté dans ce document. Ce rapport décrira  également un autre produit de diateam, la boîte SCADA virtuel, qui sert de banc d'essai pour la réalisation d'analyses et d'évaluation. Ainsi diateam garde la maîtrise sur la détection et l’analyse  des données d'attaques, celles-ci étant généralement confidentielles.

\bigskip
\bigskip
\textbf{Mots-clés: } détection d’intrusion réseau (NIDS), détection d’intrusion basée sur des anomalies, systèmes industriels, systèmes de contrôle et d'acquisition de données (SCADA), MODBUS/TCP

\newpage
\mbox{}
\thispagestyle{empty}

\clearpage

# diateam {-}

diateam is a small-medium sized enterprise located in Brest, FRANCE. They cover a wide range of services in information systems, software development, as well as cybersecurity. diateam’s R&D group utilizes the latest in technologies in its projects. Their solutions have been implemented by the French Ministry of Defense, public and private companies, in addition to the higher educational system by means of the cybersecurity trainings offered.

As a Data Scientist Intern at diateam, the following work was accomplished during the end-of-studies internship required for the Masters of Science diploma at Télécom Bretagne.

\newpage
\mbox{}
\thispagestyle{empty}

\clearpage


\tableofcontents

\cleardoublepage

\listoffigures

\cleardoublepage

\listoftables

\newpage

# Acronyms {-}

  --------  --------------------------------------------------
    A-NIDS  Anomaly-based Network Intrusion Detection System
     DARPA  Defense Advanced Research Project Agency
       EDA  Exploratory Data Analysis
       HMI  Human-Machine Interface
       HNS  Hybrid Network Simulation
       ICS  Industrial Control System
       IDS  Intrusion Detection System
       IPS  Intrusion Prevention System
       MTU  Master Terminal Unit
      NIDS  Network Intrusion Detection System
       OSI  Open Standards Interconnection
       PLC  Programmable Logic Controller
       POC  Proof of Concept
       RTU  Remote Terminal Unit
     SCADA  Supervisory Control and Data Acquisition
    TCP/IP  Transmission Control Protocol/Internet Protocol
  --------  --------------------------------------------------

\newpage
\mbox{}
\thispagestyle{empty}

\clearpage
\pagenumbering{arabic}

\setcounter{page}{17}

# Introduction

Supervisory Control and Data Acquisition Systems (SCADA) are one type of industrial control systems put in place for monitoring and controlling industrial processes, such as those in the energy or manufacturing sectors. Originally, these systems were isolated and used proprietary protocols, whose security relied predominantly on obscurity. As SCADA systems have moved towards open standards and have become more interconnected to traditional information technology systems, these critical systems have also become increasingly exposed and targeted to cyber attacks.[[@Zhu2010; @Zhu2011]]

In order to address the growing concern of the vulnerability of SCADA systems, Intrusion Detection Systems (IDS) are progressively being put strategically into place in order to monitor and analyze, and ultimately alert to devious behaviors. These devices can be either signature-, or anomaly-based, however, there are trade-offs in terms of accuracy and robustness between the two types of systems.

A hybrid IDS has been proposed by diateam under the project name SCAD\@COPS. The aim of the work presented in this paper was to realize the anomaly-based component of this Proof of Concept (POC). Based on the contributions of [[@Chifflier2014]] and [[@Diallo2014]], the POC integrates the architectural and signature-based aspects as described in their work, and where the following constraints were taken into consideration in its design -- network-based and passive only; the IDS should not interfere with, nor modify the SCADA system; and only TCP/IP data are analyzed.

This work began with an in-depth research of SCADA systems, related subject matter, IDSs and the state of the art of its application to SCADA systems, in addition to the methods of anomaly detection. Then, an exploratory analysis of the data was done, which preceded the implementation of the initial POC based on statistical metrics.

As such, this paper is organized and divided into the following major sections:

*  Chapter 1 gives an introduction to this work, and outlines its organization
*  Chapter 2 provides an overview of SCADA systems
*  Chapter 3 provides some basic networking principles
*  Chapter 4 briefly considers a few common cyber attacks
*  Chapter 5 discusses intrusion detection systems
*  Chapter 6 summarizes different approaches for detecting network intrusions
*  Chapter 7 describes the data source analyzed
*  Chapter 8 gives an overview of the exploratory data analysis
*  Chapter 9 describes the architecture and implementation of the proof of concept 
*  Chapter 10 outlines the statistical measures and features applied
*  Chapter 11 describes the testing and evaluation process
*  Chapter 12 summarizes and concludes


\clearpage


# Overview of SCADA Systems

## ICS

An Industrial Control System (ICS) comprises such systems as Supervisory Controls and Data Acquisition (SCADA), Distributed Control Systems (DCS), and smaller systems such as Programmable Logic Controllers (PLC) that are control systems predominantly used in industrial production.

ICSs were initially developed to meet the requirements of performance, reliability, safety and flexibility. They existed prior to the advancement in computer and network technology, such as public and private networks, desktop computing, or the Internet. Since ICSs remained rather isolated and obscure, the dangers of cyber security were less, or non-existent.

Typically, industrial control systems are continuously operational and commonly serve vital public services and infrastructure, thus preventive security measures must be put into place. The compromise of SCADA systems may have negative consequences including, but not limited to, substantial damage to the environment, significant risk to human safety and health, and financial and production losses.

## SCADA

A Supervisory Control and Data Acquisition system is an ICS used for monitoring equipment and controlling processes in industries such as electrical, water, oil and manufacturing. The administration over a geographically widely distributed process can be directed from a central location at the Master Terminal Unit (MTU) in SCADA systems. Changes to process controllers, the opening and closing of valves and switches, the monitoring and the measurement of information is administered from the MTU to Remote Terminal Units (RTU). Due to their economy, versatility, flexibility, and configurability, programmable logic controllers, which are small industrial field devices are widely used as RTUs.[[@Stouffer2006]] The various components of a SCADA system is shown (Figure 1).[[@Zhu2010]]

Additionally, SCADA systems commonly include PLCs, small industrial computers made to perform logic functions executed by electrical hardware, which control sensors and actuators. Human operators modify control settings, override automatic processes manually, and monitor the state of the processes under control via an Human Interface Control (HMI). It is from these HMIs that the PLCs are managed.

These systems have differing constraints and properties from those of traditional IT systems, the most prominent being that they are real-time operational systems that must always be available and run continuously without outage. Once the field devices have been put into place, they are normally left untouched, i.e., not rebooted, and left running for years. This creates the problem of the systems being more susceptible to buffer overflow due to the accumulation of fragmentation.[[@Zhu2011]]

Historically, SCADA systems resided on their own internal networks and were not connected to other networks. They implemented proprietary protocols and were, therefore, less vulnerable to network attacks. However, over time as these systems adopted open standards and leveraged traditional enterprise systems to lower costs, to increase functionality and productivity, SCADA systems are also now increasingly exposed to internal and external attacks.

```{r, echo=FALSE, fig.width=4, fig.height=5, fig.align='center', fig.cap="SCADA components"}
#setwd("~/rDia")
img <- readPNG(paste(homeDir, "imgs/SCADA_architecture.png", sep=''))
#img <- readPNG(paste(homeDir, "imgs/SCADA_architecture.png", sep=''))
grid.raster(img)
```

## Traffic characterization  

As seen in the comparative analysis done in [[@Barbosa2012]], it is shown how the traffic greatly differs between SCADA and traditional networks. Most traffic is generated by automated processes in SCADA networks as opposed to human-generated traffic predominant in traditional networks. The traffic pattern generated in SCADA networks have been found to be fairly static and repetitive, with its network topology unchanging, or rarely modified. Likewise, it is usual for there to be a limited number of applications and protocols that run on industrial systems.[[@Cheung2006]] Considerably seen over MODBUS traffic, the messages exchanged between PLCs are recurrent giving it a fixed pattern and relatively stationary process.[[@Goldenberg2013; @Barbosa2012a; @Barbosa2012b]]

\clearpage

# Networking Overview

In this section, a few fundamental networking terms are discussed. First, an outline of  the OSI model is described, followed by the TCP/IP and MODBUS protocols.

## OSI

Known as the Open System Interconnection (OSI) model, it was initially developed by the International Standards Organization (ISO) to define and characterize the communication between computing systems. The OSI model, as shown in Figure 2 ([Image source](https://engineering.linkedin.com/endorsements/geographic-trends-skills-using-linkedins-endorsement-feature)) is represented as layers, each one expressed as a protocol. Each layer serves the layer above it, and the lowest one being closest to the physical medium carrying the communication. Figure 2 depicts each layer and its role and responsibilities.

## Protocols

As SCADA systems have become increasingly interconnected to enterprise networks, they have started to leverage and operate over more modern protocols. Numerous vendors, such as Schneider, Sew and Siemens, manufacture programmable logic controllers. Depending on the device, or manufacturer, PLCs may use a proprietary protocol, such as the Siemens SIMATIC S7-300. In most cases, however, the MODBUS protocol has been widely adopted and is predominantly supported by many SCADA network appliances. As such, this work focuses primarily on examining the MODBUS/TCP protocol.

```{r, echo=FALSE, fig.pos='h', warning=FALSE, fig.width=4, fig.height=5, fig.align='center', fig.cap="OSI Model"}
img <- readPNG(paste(homeDir, "imgs/osi-model1.png", sep=''))
grid.raster(img)
```

### Transmission Control Protocol/Internet Protocol (TCP/IP)

Initially developed by the Defense Advanced Research Project Agency (DARPA) in the late 1960s, the Internet protocol suite was the result of the research and development of data transmission technologies in the United States that was utilized as a standard for military computer networking. 

TCP/IP provides reliable, ordered and error-checked delivery of streams of octets between applications running on hosts communicating over an IP network. A detailed illustration of the IP and TCP headers can be seen in Figures 3 ([Image credit: Max Baxter](http://nmap.org/book/images/hdr/MJB-TCP-Header)) and Figure 4 ([Image credit: Max Baxter](http://nmap.org/book/images/hdr/MJB-IP-Header)).

```{r, echo=FALSE, fig.pos='h', fig.width=5, fig.height=4, fig.align='center', fig.cap="IPv4 Header"}
img <- readPNG(paste(homeDir, "imgs/MJB-IP-Header.png", sep=''))
grid.raster(img)
```

```{r, echo=FALSE, fig.pos='h', fig.width=5, fig.height=4, fig.align='center', fig.cap="TCP Header"}
img <- readPNG(paste(homeDir, "imgs/MJB-TCP-Header.png", sep=''))
grid.raster(img)
```

### MODBUS Protocol

The MODBUS protocol is an open standard and popular network protocol implemented in ICS devices that were initially developed over serial communication, then later adapted for TCP/IP. It is a request/reply messaging protocol located at the application layer that was created to communicate with PLCs in industrial systems. However, due to the limited resources that PLCs have, it was designed to be a simple protocol that provides no security against unauthorized commands or interception of data.[[@Modbus2012]]. Figure 5 gives an example architecture for MODBUS TCP communication.

```{r, echo=FALSE, fig.pos='h', fig.width=5.5, fig.height=4.5, fig.align='center', fig.cap="MODBUS TCP/IP Communication Architecture"}
img <- readPNG(paste(homeDir, "imgs/modbustcpCommArch.png", sep=''))
grid.raster(img)
```

The master initiates a request and the slave sends a response containing either data or error. The common implementations of MODBUS are over Ethernet networks (MODBUS/TCP) or Serial buses (MODBUS/RTU). Both forms of MODBUS contain the Packet Data Unit (PDU),  the component consisting of a function code and data that is independent of the communication layer.

Attached to the PDU is the application specific addressing and error checking, which together comprise the Application Data Unit (ADU). In MODBUS/TCP, the ADU is encapsulated in the TCP packet, so error checking is omitted from the MODBUS/TCP ADU, because it is already provided in the TCP layer (Figure 6).

```{r, echo=FALSE, fig.pos='h', fig.width=4, fig.height=2.75, fig.align='center', fig.cap="MODBUS/TCP Frame"}
img <- readPNG(paste(homeDir, "imgs/modbusADU.png", sep=''))
grid.raster(img)
```

Included in the MODBUS Application Protocol (MBAP) are:

-  Transaction ID - 2 bytes - identifies request/response pairs
-  Protocol ID - 2 bytes - is always 00 00 for MODBUS protocol
-  Length - 2 bytes - identifies the number of bytes in the following message
-  Unit ID - 1 byte - used to distinguish which slave is addressed when several slaves use the same IP address

In MODBUS/TCP, port 502 is typically the default port reserved for MODBUS communication. Furthermore, when identifying MODBUS requests, the services specified are indicated by the MODBUS function code. Appendix A lists the public function codes available.

With no authentication and authorization mechanisms, data integrity checks, or encryption due to the simple design of the MODBUS protocol, SCADA network components do not verify identity or permissions, determine legitimacy of message content, nor provide confidentiality.

\clearpage

# Common Attacks on SCADA

[[@Hadziosmanovic2010; @Krotofil2013; @Lemay2013; @Rodrigues2011; @Stouffer2006]] define threats and vulnerabilities, security issues, as well as policies and best practices, and recommendations on how to best secure SCADA systems. Nonetheless, cyber attacks continue to increase as SCADA systems become more exposed and as the attacks grow in sophistication. Due to the private nature of the data, however, little has been published regarding MODBUS/TCP attacks apart from the work of Digital Bond[^1].

[^1]: http://www.digitalbond.com

Leveraging existing enterprise network infrastructure, SCADA systems are also at risk to the same threats that typical IT systems encounter. In addition, as SCADA systems are upgraded less frequently and continue to run on legacy systems, they are rendered even more vulnerable to various attacks that may be prevented by deploying upgrades that address newer and known threats. In [[@Zhu2011]], outlines and describes in detail the various methods of cyber attacks on software and hardware and ways of compromising SCADA systems.

The following is a non-exhaustive list of of attacks that provides an overview of just some of the common attacks that have been exploited against SCADA systems[[@Morris2013]]:

## Command Injection

In regards to command injection attacks, the attacker may intercept and alter, or insert conceivably malicious commands that are then unknowingly executed in the system. For example, a couple of known command injection type attacks over the web are SQL Injection and Cross-Site Scripting (XSS) attacks. 

Concerning SCADA systems, unauthorized commands meant to alter the control and configuration of ICSs are injected to modify, or interrupt communication and processes. MODBUS communication is intercepted, where an attacker injects MODBUS functions intended to modify the industrial process. Since the MODBUS/TCP protocol was not designed with security taken into account and has no encryption or sophisticated security precautions, it is vulnerable to the manipulation of the function code or data field sent in the MODBUS request.

## Response Injection

The  nature of response injection attacks is that they perform unauthorized write requests. Commonly seen in ICSs, polling is continuously done in order to audit the state of remote processes. Over MODBUS/TCP, there is frequent request and response communication between the MTU and RTUs. Perpetrators may craft response packets that are subsequently inserted into the communication loop and, if timed accordingly, is received as the first response to a query thereby rejecting further responses as invalid.

## Denial of Service  

In an attempt to render services unavailable and to stop the proper functioning of a system, Denial-of-Service (DoS) attacks either try to bring down and crash the service, or flood all resources preventing legitimate users from accessing the service. Attacks of this type on SCADA systems try to either reboot MODBUS servers or manipulate the controls to take them out of service. In other cases, an endpoint is inundated to the point where it cannot take on further requests. Considering that PLCs have very limited resources and capacity, it does not take very long to overwhelm these devices and disrupt operations.

## Reconnaissance

In a reconnaissance attack there is unauthorized reading of data, where this type of attack generally surveys a network and identifies connected devices in order to ascertain the network architecture and topology. Once the attacker gains access to the network, they may carry out different levels of scanning over the network, such as address, port and endpoints scanning. In the case of SCADA systems, with MODBUS/TCP being the prevailing protocol implemented in ICS devices, function scanning is also attempted.

## Zero-day Attacks

Attacks that exploit previously unknown vulnerabilities and security holes before a vendor can react and correct them via a patch are known as zero-day attacks. As deploying upgrades and patches to ICSs are relatively slow and infrequent, ICSs are highly susceptible to the weaknesses discovered in software or hardware before they are corrected. A well-known malware meant to target industrial PLCs, Stuxnet was designed to exploit an assortment of zero-day flaws.[[@Karnouskos2011]]

\newpage

# Intrusion Detection Systems

An Intrusion Detection System (IDS) is a security mechanism put into place with the purpose of observing, analyzing and detecting unauthorized access to, or malicious activity on, resources and data, which are then alerted to, and reviewed by, security analysts. An IDS may act in a passive or reactive manner, the prior in which unusual activity is logged and an alert is sent to a monitoring system. The latter, referred to as an Intrusion Prevention System (IPS), is where additional steps, such as terminating, or denying connections, may be taken in response to suspicious activity.

The initial model for intrusion detection systems was presented by [[@Denning1987]], where Denning described the framework for the design and implementation of a general-purpose intrusion detection system. The ideal detection system should contain the following characteristics and have these capabilities [[@Bishop2003]]:

*  detect a broad variety of intrusions
*  provide detection of intrusions in a  timely manner
*  analysis should be presented in a simple format
*  these tasks must be executed accurately

There are two types of IDSs, which are described as follows:

## Host IDS

Host-based IDSs are placed directly on each individual host to be monitored and has direct access to the the resources on the host. For instance, the host-based IDS may be placed directly on the MODBUS client, or server, to monitor what resources and processes are being accessed and running.

## Network IDS

Network-based IDSs are placed at various strategic points on the network, for example, connected to the monitor port of a switch, and the traffic that occur between hosts is inspected by listening to and analyzing network events.

Threats may be identified by NIDSs by the following means:

### Signature-based

The data captured by the NIDS is examined and compared to an existing signature database that have attributes of known attacks. Although this method provides for higher accuracy (lower number of false positives) in detecting known threats, the signature database needs to be continually maintained and updated frequently.

### Anomaly-based  

In an Anomaly-based NIDS (A-NIDS), any deviation from “normal” activity is flagged as an alarm. An initial profile of the system is first created where normal activity is observed. Once established, the A-NIDS collects data from network events and based on different metrics or measurements, looks for activity that differs significantly from the normal profile and raises an alarm. The advantage of an A-NIDS is that no a priori knowledge is required of previous known attacks and can be used to define signatures for malicious behaviour, however it cannot identify a specific attack and has a greater number of false alarms (false positives) than signature-based IDS.

In comparison to signature-based NIDS, anomaly-based methods are less mature. Nonetheless, there has been significant growth into research on the methods used in anomaly detection, particularly those which minimize the rate of false positives. The primary methods of anomaly detection are statistical, data mining, and machine learning, which generally follow through the stages that are briefly described below.[[@Yasakethu2013; @Garcia2009, @Wang2011]]

The first (parameterization) phase of implementing an anomaly-based detection system is to create the baseline profile of the system characteristics and behaviour. Then a model is developed using the training set created using one of the methods outlined below during the training phase. A comparison of a subset of these methods is given (Figure 8).[[@Garcia2009]] In the final stage, detection of abnormal behaviour is analyzed by comparing the observed network traffic to the model. Any significant deviations are signaled and an alert is fired. Figure 7 [[@Garcia2009]] models this process.

```{r, echo=FALSE, fig.pos='h', fig.width=4.5, fig.height=4.5, fig.align='center', fig.cap="Functional Architecture of an A-NIDS"}
img <- readPNG(paste(homeDir, "imgs/anids_process_funct_archit.png", sep=''))
grid.raster(img)
```

Most IDSs found in the market-place are commonly network, signature-based IDSs and although anomaly-based detection systems are relatively immature, they provide a greater possibility of detecting unknown attacks. The trade-off between the two types of systems are primarily in the accuracy with which they detect a real attack, or an anomaly. Properly configured signature-based systems rarely raise false alarms, but unlike anomaly-based systems, are less capable of detecting novel attacks.

Until relatively recently, the application of IDSs to SCADA systems was not prevalent, however there has been increasing interest and different approaches and implementations can be seen in the literature.[[@Yasakethu2013; @Garcia2009; @Wang2011; @Valdes2009; @Sayegh2014]]

\newpage

# Techniques of Network Intrusion Detection

Numerous anomaly-based methods and techniques have been studied and implemented in detecting network intrusions. These include statistical, data mining and machine learning.[[@Garcia2009, @Maglaras2014a; @Wang2004; @Wang2011; @Sousan2011; @Cheung2006; @Cunningham2003; @Fovino2010; @Kim2013; @Patcha2007; @Pathan2014; @Yang2005; @Verba2008; @Verwoerd2002; @Wang2006; @Mantere2013; @Yang2014; @Yu2012; @Zhou2015]] Figure 8 provides a brief summary of these techniques.

## Statistical

Statistical approaches are based on either setting thresholds and applying them to specific variables, or are based on changes in distributions over a period of time observed. In the first case, an upper and lower bound are established to define an appropriate range of values for the individual variables measured. Earlier methods began by using the univariate model where single variables are analyzed, and later, multivariate models were applied in which highly correlated metrics were used, as they were considered to be more effective at distinguishing anomalies. In the second case, considered as a time-series model, a window of data is used to compute the mean of its distribution in order to determine the thresholds.[[@Callegari2008; @Marchette2003; @Marchette2004; @Meza2009; @Wang2009; @Wang2011]]

## Data Mining

Data mining, also known as Knowledge Discovery in Databases (KDD), is the the process of extracting information and detecting interesting patterns from data. A good deal of work is involved prior to the mining process in understanding and preparing the data for the mining process and analysis. Some data mining techniques include, but are not limited to association rules, language processing, and decision trees and consist of such algorithms as Apriori, K-Means, and K-Medoids to mention a few.[[@Dipali2013; @Jayasimhan2012; @Lee2001; @Joshi2013; @Lee1999; @Mara2011; @Miao2010; @Morkhade2013; @Munz2007; @Nader2014; @Naiping2010; @Singh2013; @Shukla2014; @Syarif2012; @Zhao2010]]

## Machine Learning

In the machine learning approach an algorithm is trained to learn against a set of data that has been previously identified, or labeled, and as more data becomes available, the greater the accuracy of the model. Prominent methods of machine learning are Bayesian and Neural Networks, SVM, kNN, clustering and outlier detection.[[@Gao2010; @Golmah2014; @Jiang2013; @Khan2007; @Linda2009; @Maglaras2014; @Mantere2012; @Meza2009; @Mukkamala2006]]

Similarities and overlap can be seen between the techniques above as they have evolved and originated from, and are intersections of, the fields of computer science, statistics, artificial intelligence, and database systems. Each of these methods presents its advantages and drawbacks, and in evaluating them, it will be important to consider the time and complexity in the processing and analysis of data, the availability of previously identified data, as well as the legibility of results, that is, how easily the results can be read and interpreted.

```{r, echo=FALSE,fig.align='center', fig.cap="Fundamentals of A-NIDS Techniques"}
img <- readPNG(paste(homeDir, "imgs/anids_tech_comp.png", sep=''))
grid.raster(img)
```

\clearpage

# Data Source

It is usual for network data to contain private and sensitive information, and therefore a limited number of datasets exist for testing.  Consequently, it is difficult to evaluate and assess the accuracy and validity, as well as to make comparisons across the different methods applied in anomaly detection.

One of the only publicly available datasets containing network traffic data has been provided by the US Defense Advanced Research Projects Agency (DARPA).[[@DARPA1999]] Network IDS analysis and studies have commonly been carried out using the DARPA dataset. In this study, the analysis has been completed using data acquired from a simulated testbed, the Virtual Scada Box. 

## HNS and Virtual Scada Box

diateam has developed a system, hynesim (HNS), that is a distributed platform used in simulating complex information and network systems. With its ergonomic graphical user interface, hynesim has a distributed architecture and modular system, which allows for the inter-connection between real, as well as virtual systems.

Incorporated into Virtual Scada Box, hynesim is the principal component where there is a virtual system that simulates a water treatment plant. Virtual Scada Box includes components such as the PLCs, HMIs, and a virtual water pump that have been connected over a TCP/IP network.

The data analyzed were derived from a simulated network running on the Virtual Scada Box. A packet capture file was created via Wireshark, which captured the network traffic simulated over a virtual SCADA network.

## PCAP[^2]
[^2]: https://www.winpcap.org/ntar/draft/PCAP-DumpFileFormat.html

This section describes the format used for the packet capture file format of the dumped packets.

The general structure is in a block format as shown below, with the following fields:

* Block Type (32 bits) - unique value that identifies the block.
* Block Total Length - total size in bytes.
* Block Body - content.
* Block Total Length - total size in bytes. that is duplicated for allowing backward file navigation.   

\newpage

```{r, warning=FALSE, echo=FALSE, comment='', fig.align='center', fig.cap="PCAP Block Structure"}
cat("
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Block Type                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      Block Total Length                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
/                          Block Body                           /
/          /* variable length, aligned to 32 bits */            /
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      Block Total Length                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    
    ")
```

## MODBUS/TCP Packets

Example MODBUS packets, with MODBUS data values:

### Request
```{r, warning=FALSE, echo=FALSE, comment='', fig.align='center', fig.cap="PCAP Block Structure"}
cat("
65  572.608117000	192.168.12.51	192.168.12.253	MODBUS/TCP	66	   query: trans:
20; unit:   1, func:   4: Read input registers

0000  00 80 f4 0f 35 aa 00 18  63 37 9b 5b 08 00 45 00   ....5... c7.[..E.
0010  00 34 41 35 40 00 80 06  1f 0e c0 a8 0c 33 c0 a8   .4A5@... .....3..
0020  0c fd 09 c3 01 f6 05 1a  47 65 63 b7 1f c5 50 18   ........ Gec...P.
0030  fa 14 3e 57 00 00 00 14  00 00 00 06 01 04 00 00   ..>W.... ........
0040  00 01    
    ")
```

### Response
```{r, warning=FALSE, echo=FALSE, comment='', fig.align='center', fig.cap="PCAP Block Structure"}
cat("
66	572.617795000	192.168.12.253	192.168.12.51	MODBUS/TCP	65	response: trans:
20; unit:   1, func:   4: Read input registers

0000  00 18 63 37 9b 5b 00 80  f4 0f 35 aa 08 00 45 00   ..c7.[.. ..5...E.
0010  00 33 89 26 40 00 40 06  17 1e c0 a8 0c fd c0 a8   .3.&@.@. ........
0020  0c 33 01 f6 09 c3 63 b7  1f c5 05 1a 47 71 50 18   .3....c. ....GqP.
0030  22 08 9f 5a 00 00 00 14  00 00 00 05 01 04 02 00   \"..Z.... ........
0040  75
    ")
```

\newpage

# Exploratory Data Analysis 

Originally championed by John Tukey[[@Tukey1977]], Exploratory Data Analysis (EDA) is an initial approach to understanding a data set in order to get a “feel” for the data, to summarizing its essential characteristics and to studying patterns in the data. Moreover, exploratory data analysis frequently incorporates graphical representations beyond using quantitative techniques.

Conducting EDA possibly gives further insight into the form and structure of the data set, in addition to extracting value, visualizing the data, and just as importantly, in communicating it. The initial phase of exploratory data analysis was conducted in order to better understand the data. This section presents a short list of statistical terminology, followed by the exploratory data analysis carried out on the network traffic data captured over the simulated SCADA network and shows the different ways they can be visualized. The analysis, reporting and visualization was done using R and RStudio.   	

## Statistical Definitions

### Mean

The (arithmetic) mean is a measure of central tendency, which is a single value which represents an average of the sample or population. It is calculated by dividing all the observations by the number of observations.

### Median

Another measure of central tendency is the median, however, in this case, the median is determined by first ordering the observations by magnitude. Then the median is taken as the value which falls in the middle, or the average of the two middle values in the case of an even number of observations. The median is better suited when there are observations, or outliers, that fall way outside the norm. These are extreme values that differ greatly from other values in the data set.

### Variance

The variance is the expected value of the squared differences between the random variables and its mean that is always positive. It gives an indication of how far apart the values are from the mean and each other.

$$ var[X] = E[(X - E[X])^2] $$

### Standard Deviation

The standard deviation is a measure of dispersion, or how spread out a random variable is around its mean. It is calculated as the square root of the variance and is, unlike the variance, expressed in the same terms (unit) as the data.

$$ \sigma = \sqrt(var[X]) $$

### Covariance

A measure of how closely two variables change, or vary together is the covariance. Random variables whose covariance is 0 is said to be uncorrelated.

$$ \sigma(X, Y) = E[(X - E[X])(Y-E[Y])] $$

### Correlation

Correlation is the strength between the relationship of, or dependence between, two variables whose value have been normalized and is typically bounded between the values of -1 and 1. It describes the magnitude and the direction of the relationship. If the correlation is positive, their values increase together, and if it is negative, one value decreases as the other value increases.

$$ \rho(X, Y) = \sigma(X, Y) / (\sigma [X] \sigma [Y]) $$

## Visual Representations

### Pie chart

A pie chart is a circular diagram representing numerical proportions as slices of the pie.

### Scatter plot

A diagram showing a collection of points as depicted by the coordinates between two variables on a plane. One axis represents the independent variable, whereas the other represents the dependent variable.

### Histogram

A graphical representation which shows the distribution of continuous numerical values is a histogram and can be representative of a probability distribution. A frequency histogram is a univariate graphical way to show frequency counts of a value showing bars of different heights.

### Bar chart

Similar to a histogram, a bar chart shows the distribution of values of a given variable with the data categorized.

### Boxplot

An effective and graphical method for visualizing outliers is the boxplot. It displays the data in terms of interquartiles, where outliers are indicated as individual points. (Figure 9: Boxplot Image Source[[@Lafaye2013]])

```{r, echo=FALSE, fig.width=4, fig.height=4, fig.align='center', fig.cap="Boxplot"}
img <- readPNG(paste(homeDir, "imgs/boxplot.png", sep=''))
grid.raster(img)
```

### Heat Map

A heat map displays data in a matrix where the values are represented by a range of colors. Typically displayed in 2D, larger values are usually shown in darker colors and smaller values in lighter colors on a heat map. They can also be accompanied by a dendrogram, a tree diagram that illustrates clusters.

### Network Graph

Modeling the relations between objects, another mathematical structure is the graph comprised of nodes, or vertices, and edges. Depending on the nature of the relationship, a graph may be either cyclic or acyclic, directed or undirected. Attributes of a node or edge may be reflected in the graph as well.

## Data Analysis

Below is a summary of the packet capture file that was created under "normal" conditions over the virtual SCADA network.

 **capture_schneider_20150903_normal.pcapng**  
 ----------------------------                 ----------------------------   
 **File**  
 Length:                                      3969470 bytes  
 Format:                                      Wireshark - pcapng  
 Encapsulation:                               Ethernet  
 Packet size limit:                           65535  
 **Time**  
 First packet:                                2015-09-03 15:26:26  
 Last packet:                                 2015-09-03 15:36:29  
 Elapsed:                                     00:10:02  
 **Traffic Captured**  
 Packets                                      39784  
 B/t first and last pkt                        602,865 sec  
 Avg. packets/sec	                            65,992  
 Avg. packet size      	                      65,343 bytes  
 Bytes			                                  2599593  
 Avg. bytes/sec      		                      4312,063  
 Avg. Mit/sec        		                      0,034  
 ----------------------------                 ----------------------------
 
Once the network traffic was captured and saved in a PCAP file, Wireshark provides the capability to export the raw data into various comma delimited files in order to do further analysis. Exported files were created with TCP endpoints, TCP conversations, as well as the entire pcap file, each as a CSV file. (Appendix B)

## Network Analysis

### Network Graph and Topology

Figure 10 depicts the network topology of the components and end points on the simulated network.

```{r, echo=FALSE, message=FALSE, fig.pos="h", warning, fig.height=5, fig.width=5, fig.align='center', fig.cap="SCADA Network Graph"}
#g <- graph.data.frame(normalTCPConvDT[,.(Address.A, Address.B, Packets, Bytes, Duration)], directed=FALSE)
g <- graph.data.frame(sewTCPConvDT[,.(Address.A, Address.B, Packets, Bytes, Duration)], directed=FALSE)
gAdjMtx <- get.adjacency(g)  # adjacency mtx
gAdj <- graph.adjacency(gAdjMtx, mode="undirected", weighted=TRUE)
V(gAdj)$size <- degree(gAdj)*40  # node size according to degree of centrality
eW <- E(gAdj)$weight  # edge weights
eW <- ceiling(eW/max(eW)*55)
eW[eW>10] <- 10
plot.igraph(gAdj, edge.width=eW)
rm(g, gAdjMtx, gAdj, eW)
invisible(dev.off())
```

The following Tables 3-7 list the data extracted from the packet capture file:

```{r, comment='', echo=FALSE, warning=FALSE, message=FALSE}
kable(normalModbusDT[,.(count=.N), by=.(ip.src, ip.dst, mbtcp.modbus.unit_id)], caption='Source / Destination / UnitID')
```
  
```{r, comment='', echo=FALSE, warning=FALSE, message=FALSE}
kable(normalModbusDT[,.(count=.N), by=.(ip.src)], caption='Sources')
```

```{r, comment='', echo=FALSE, warning=FALSE, message=FALSE}
kable(normalModbusDT[,.(count=.N), by=.(ip.dst)], caption='Destination')
```

```{r, comment='', echo=FALSE, warning=FALSE, message=FALSE}
kable(normalModbusDT[,.(ip.dst.unit_id = paste(ip.dst, mbtcp.modbus.unit_id, sep="/")),
                    by=.(ip.dst, mbtcp.modbus.unit_id)], caption='Destination / UnitID')
```
  
\newpage

```{r, comment='', echo=FALSE, warning=FALSE, message=FALSE}
kable(normalModbusDT[,.(src.func = paste(ip.src, mbtcp.modbus.func_code, sep="/"))
                       , by=.(ip.src, mbtcp.modbus.func_code)], caption='Source / Function Code')
```

## Packet Analysis

Figure 11 depicts a boxplot indicating packet size.

```{r, echo=FALSE, warning=FALSE, message=FALSE, fig.pos='h', fig.width=4.5, fig.height=4, fig.align='center', fig.cap="Source Packet Size Boxplot"}
#ggplot(normalTCPConvDT, aes(x = factor(0), y = Bytes/1e6)) +
ggplot(sewTCPConvDT, aes(x = factor(0), y = Bytes/1e6)) +
  geom_boxplot(fill="darkorchid3") + xlab("") + scale_x_discrete(breaks = NULL) +
  facet_grid(~Address.A) +
  ylab("MBytes") +
  theme( plot.margin = unit(c(4,2,1,2), "cm") )

invisible(dev.off())
```

### MODBUS/TCP Request/Response Packet Statistics (Appendix C)  

MODBUS/TCP **requests** are identified by packets having destination port number 502 (Figure 13).

```{r, echo=FALSE, warning=FALSE, message=FALSE, fig.pos='h', fig.width=5, fig.height=3.45, fig.align='center', fig.cap="Boxplot of Request Packets"}
requests<-normalModbusDT[tcp.dstport=="502"]

p1 <- ggplot(requests, aes(x=factor(0))) +
  geom_boxplot(aes(y=frame.time_relative), fill="aquamarine4") + xlab("") +
  scale_x_discrete(breaks = NULL)
    
p2 <- ggplot(requests, aes(x=factor(0))) +
  geom_boxplot(aes(y=frame.time_delta)) + xlab("") +
  scale_x_discrete(breaks = NULL)
    
p3 <- ggplot(requests, aes(x=factor(0))) +
  geom_boxplot(aes(y=frame.len)) + xlab("") + scale_x_discrete(breaks = NULL)
    
p4 <- ggplot(requests, aes(x=factor(0))) +
  geom_boxplot(aes(y=mbtcp.len)) + xlab("") + scale_x_discrete(breaks = NULL)
    
grid.arrange(p1, p2, p3, p4, ncol=2, nrow=2)

invisible(dev.off())
```

MODBUS/TCP **responses** are identified by packets having source port number 502 (Figure 14).

```{r, echo=FALSE, warning=FALSE, message=FALSE, fig.pos='h', fig.width=5, fig.height=3.45, fig.align='center', fig.cap="Boxplot of Response Packets"}
responses<-normalModbusDT[tcp.srcport=="502"]

p1 <- ggplot(responses, aes(x=factor(0))) +
  geom_boxplot(aes(y=frame.time_relative), fill="steelblue2") + xlab("") +
  scale_x_discrete(breaks = NULL)
    
p2 <- ggplot(responses, aes(x=factor(0))) +
  geom_boxplot(aes(y=frame.time_delta)) + xlab("") +
  scale_x_discrete(breaks = NULL)
    
p3 <- ggplot(responses, aes(x=factor(0))) +
  geom_boxplot(aes(y=frame.len)) + xlab("") + scale_x_discrete(breaks = NULL)
    
p4 <- ggplot(responses, aes(x=factor(0))) +
  geom_boxplot(aes(y=mbtcp.len)) + xlab("") + scale_x_discrete(breaks = NULL)
    
grid.arrange(p1, p2, p3, p4, ncol=2, nrow=2)

invisible(dev.off())
rm(p1,p2,p3,p4)
```

\clearpage

```{r, echo=FALSE, warning=FALSE, message=FALSE, fig.pos='h', fig.width=6, fig.height=4.75, fig.align='center', fig.cap="Bar Charts of Packet Counts"}

# Number of Packets by Source
bc1 <- ggplot(normalModbusDT, aes(x=ip.src)) + geom_bar(stat="bin", fill="#FF9999", colour="black")
bc1 <- bc1 + ylab("Packet Count") + ggtitle("Source")
bc1 <- bc1 + theme(axis.text.x = element_text(angle=90),
                   plot.title = element_text(size=10))

# Number of Packets by Destination
bc2 <- ggplot(normalModbusDT, aes(x=ip.dst)) + geom_bar(stat="bin", fill="#56B4E9", colour="black")
bc2 <- bc2 + ggtitle("Destination") + ylab("Packet Count")
bc2 <- bc2 + theme(axis.text.x = element_text(angle=90),
                   plot.title = element_text(size=10))

grid.arrange(bc1, bc2, ncol=2)
```

```{r, echo=FALSE, warning=FALSE}
rm(bc1, bc2)
```

```{r, echo=FALSE, warning=FALSE, message=FALSE, fig.pos='h', fig.width=5.5, fig.height=3.5, fig.align='center', fig.cap="Scatterplot of Time as a Function of Frame Number"}
ggplot(normalModbusDT, aes(x=frame.number)) +
  geom_line(aes(y=frame.time_relative, color="frame.time_relative"))+
  geom_point(aes(y=mbtcp.len, color="mbtcp.len")) +
#  ggtitle("Scatterplot of Time Recorded \nFunction of Frame Number") +
  theme(axis.text = element_text(size = 13),
#        plot.title = element_text(face="bold"),
        plot.margin = unit(c(1, 0, 1, 0), "cm")) +
  scale_colour_manual(name='', values=c('frame.time_relative'='olivedrab',
                                        'mbtcp.len'='firebrick'), guide='legend') +
  guides(colour = guide_legend(override.aes = list(linetype=c(1,0)
                                                   , shape=c(NA, 16))))
invisible(dev.off())
```

```{r, echo=FALSE, warning=FALSE, message=FALSE, fig.pos='h', fig.height=3.5, fig.width=3.5, fig.align='center', fig.cap="Boxplot of Modbus/TCP Data Length"}
ggplot(normalModbusDT,  aes(x=factor(0), y=mbtcp.len)) + geom_violin() +
  xlab("") + scale_x_discrete(breaks = NULL) + coord_flip() +
#  ggtitle("Boxplot of MODBUS/TCP Data Length") +
  theme(#plot.title = element_text(face="bold"),
        plot.margin = unit(c(0, 0, 2, 0), "cm"))

invisible(dev.off())
```

```{r, warning=FALSE, message=FALSE, echo=FALSE, fig.pos='h', fig.align='center', fig.cap="Graph of MODBUS Data Values over Time by MODBUS  Reference Number"}
ggplot(mergedSewDT, aes(x=frame.time_relative, y=d, color=mbtcp.modbus.reference_num)) +
  geom_point() + facet_grid(mbtcp.modbus.reference_num~resp.func.code) +
#  ggtitle("MODBUS Data Values \nOver Time by Reference Number") + 
  scale_fill_brewer(palette="Spectral") +
  theme(#plot.title = element_text(face="bold"),
        plot.margin = unit(c(0, 0, 2, 0), "cm"),
        legend.position = "top", legend.title = element_text(size=10))
invisible(dev.off())
```

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.pos='h', fig.align='center', fig.cap="Graph of MODBUS Data Values over Time by Function Code"}
ggplot(mergedSewDT, aes(resp.time.rel, d, color=mbtcp.modbus.reference_num)) +
  geom_point() + facet_grid(~resp.func.code) +
  scale_fill_brewer(palette="Set1") +
#  ggtitle("MODBUS Data Value Over Time by Function Code") +
  theme(#plot.title = element_text(face="bold"),
        plot.margin = unit(c(0, 0, 2, 0), "cm"),
        legend.position = "top", legend.title = element_text(size=10))
invisible(dev.off())
```

### MODBUS/TCP Data[^3] Analysis 
[^3]: https://www.wireshark.org/docs/dfref/m/mbtcp.html

The following analysis was done over the previous dataset that was processed
to merge response packet to the request packet of the same transaction. An additional
field "d" is the data field "resp.data" converted from a hex to a decimal value.
(Appendix D)

### MODBUS Data Value Statistics

```{r, comment='', echo=FALSE, warning=FALSE, message=FALSE}
mergedSewDT[,.(count=.N, d.min=min(d), d.mean=mean(d, na.rm=T), d.max=max(d),
            d.sd=sd(d, na.rm=T), min.resp.time.rel=min(resp.time.rel),
            min.resp.time.rel= max(resp.time.rel)),
            by =.(resp.func.code, mbtcp.modbus.reference_num)][
           order(resp.func.code, mbtcp.modbus.reference_num)]
```

\clearpage

Under normal activity, it is typical to see MODBUS function code 4 (0x04) requested, as shown in all figures grouped by function code. This is the function code that corresponds to Read Input Registers.

It can also be seen in Figures 17, 18 and 22 how cyclical the processes are in the system.

```{r, echo=FALSE, warning=FALSE, message=FALSE, fig.pos='h', fig.align='center', fig.cap="Bar Chart of MODBUS Reference Numbers by Function Code"}
# Frequency of Reference Numbers by Function Code
ggplot(normalModbusDT, aes(x=mbtcp.modbus.reference_num, fill=mbtcp.modbus.reference_num)) +
  geom_bar(stat="bin") +
  facet_grid(~mbtcp.modbus.func_code) +
#  ggtitle("Bar Chart of Reference Numbers by Function Code") +
  scale_fill_brewer(palette="Set1")

invisible(dev.off())
```

In Figures 17-20, reference numbers refer to the register number of the PLC devices. The reference numbers indicate the following:

-  0 - state
-  1 - errors
-  2 - water level
-  3 - pump speed

```{r, echo=FALSE, warning=FALSE, message=FALSE, fig.pos='h', fig.width=4.5, fig.height=3.5, fig.align='center', fig.cap="Boxplot of MODBUS Data Values by Function and Reference Number"}
ggplot(mergedSewDT, aes(x = factor(0), y = d)) +
  geom_boxplot(fill="lightpink4") +
  facet_grid(mbtcp.modbus.func_code~mbtcp.modbus.reference_num) +
  xlab("") + scale_x_discrete(breaks = NULL) +
  theme( plot.title = element_text(size=10))
#  theme(plot.margin = unit(c(0, 1, 5, 1), "cm")  +
#  ggtitle("Boxplot of MODBUS Data Values\n by Function/Reference Number")

invisible(dev.off())
```

```{r, echo=FALSE, warning=FALSE, message=FALSE, fig.pos='h', fig.width=4.5, fig.height=3.75, fig.align='center', fig.cap="Scatterplot Matrix of Pairs of Variables"}
pairs(mergedSewDT[,.(mbtcp.len, mbtcp.modbus.func_code=as.numeric(mbtcp.modbus.func_code),
                     mbtcp.modbus.reference_num=as.numeric(mbtcp.modbus.reference_num) , d)])
```

\clearpage

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.pos='h', fig.align='center', fig.cap="3D Scatterplot of MODBUS Reference Number\n and Data Over Time for Function Code 4"}
cloud(resp.time.rel ~ d + mbtcp.modbus.reference_num | resp.func.code, data = mergedSewDT[resp.func.code=="4"],
      col.point = mergedSewDT$mbtcp.modbus.reference_num, pch= 19,
      xlab = "d", ylab = "refNum", zlab = "resp.time.rel",
      panel.aspect = 0.7,
#      main="3D Scatterplot \nReference Number, Data Value Over Time for Function Code 4",
      key = list(points = list(pch = 19, col = seq_along(levels(mergedSewDT$mbtcp.modbus.reference_num))), 
                 text = list(levels(mergedSewDT$mbtcp.modbus.reference_num)), space = 'top',
                 columns = nlevels(mergedSewDT$mbtcp.modbus.reference_num)))
invisible(dev.off())
rm(cor.test.2.sample)
```

\clearpage

# Proof of Concept

The SCAD\@COPS proof of concept incorporates the methods as outlined in [[@Chifflier2014; @Diallo2014]], which define the architectural and signature-based detection system, and the last component being the anomaly-based detection system. The signature-based IDS component was previously implemented and configured using Suricata. The initial POC will contain an anomaly-based IDS using statistical methods, which is what this project has concentrated on.

## Architecture Overview

Network IDSs are utilized for security monitoring, but are themselves also vulnerable and exposed to attacks. [[@Chifflier2014]] proposes an architecture for the IDS sensor devices and software to minimize the possibility of attacks on it. The two approaches presented are to: 

- reinforce software security- reduce the area of attack, remove unused applications and services, and reduce permissions and privileges of important processes
- isolate system components- partition and separation between users and processes via virtualization

In Figure 23, an example is shown of the placement of the IDS and its supporting DB, connected to other SCADA components.

```{r, echo=FALSE, fig.pos='h', fig.width=5.5, fig.height=2.70, fig.align='center', fig.cap="Technical Architecture"}
img <- readPNG(paste(homeDir, "imgs/techArchitecture.png", sep=''))
grid.raster(img)
```

Based on the recommendations of [[@Chifflier2014]], in order to address the security concerns of the IDS appliance itself, the architecture contains a partition of the various components and isolates each IDS instance from one another, as can be seen in Figure 24. All resources are set to read-only mode, with limited authorized access.  For maintenance, updates are deposited in a dedicated area and then copied over to another reserved area that are either executed by a scheduled job or via a trigger. A Mirabox is used as the embedded system running the latest stable version of Debian and virtual private networks to communicate between the internal IDS and the supervisory system (Figure 24).[[@Chifflier2014]]

[[@Diallo2014]] advises the strategic placement of the monitoring devices throughout the SCADA system on a dedicated network for supervision, and presents the two different approaches of a centralized or a distributed system.

```{r, echo=FALSE, fig.pos='h', fig.align='center', fig.cap="Architecture of secure IDS "}
#setwd("~/rDia")
img <- readPNG(paste(homeDir, "imgs/arch_sys_detect.png", sep=''))
grid.raster(img)
```

### Signature-based IDS

In  [[@Chifflier2014]] and [[@Diallo2014]], the signature based IDS is described and the use of the Suricata IDS software with MODBUS protocol are proposed. Rules are configured that conform to, and verify the correct and normal behaviour of a SCADA system.

### Anomaly-based IDS

In the scope of the SCAD\@COPS project, the anomaly-based component will be derived from various statistical properties, that will be discussed subsequently in Chapter 10.

## Implementation

All software and tools applied and implemented in the SCAD\@COPS project are free and open
source (Appendix E).

### Process Flow

Figure 25 shows the steps involved in the entire process from acquiring the data, computation and analysis, to setting the IDS to detection mode.

* Step 1: Data Acquisition During Normal Activity - From the IDS appliance, 
        sniff the network traffic, extract and store data in a database.
* Step 2: Statistical Process and Analysis
    + 2.1 Process data - Perform any transformation, filtering and data
            cleansing necessary.
    + 2.2 Calculate and determine statistical measures.
    + 2.3 Configure appliance with statistical parameters.
* Step 3: Detection Mode - Appliance is set to detection mode.

```{r, echo=FALSE, fig.pos='h', fig.width=6, fig.height=5, fig.align='center', fig.cap="Process Flow"}
#setwd("~/rDia")
img <- readPNG(paste(homeDir, "imgs/process.png", sep=''))
grid.raster(img)
```

### Data Acquisition

As illustrated in Section 9.1, Figure 24, the data is acquired by one of the components of the NIDS, which has been configured to only monitor network traffic:

*  Wireshark - An initial packet capture file was created over the simulated network traffic using Wireshark. Using its export facilities, various files were created for further analysis, with information such as TCP endpoints, conversations, etc.
*  TShark - The pertinent variables pertaining to the MODBUS/TCP application protocol enclosed in the packet data were extracted and parsed by TShark.

### Statistical Analysis and Processing

The statistical process was implemented using various components to handle specific steps. Each component used was initially selected to manage a particular task of the process according to its ease and efficiency of development, as well as its processing time (Appendix F). Once captured from the monitoring device on the IDS appliance, the packet capture file can be processed offline. Configuration files are subsequently generated in JSON format after the statistical computations, which can then be uploaded to the IDS appliance.

```{r, echo=FALSE, fig.pos='h', fig.width=6, fig.height=5, fig.align='center', fig.cap='Statistical Computational Process'}
img <- readPNG(paste(homeDir, "imgs/statsProcess.png", sep=''))
grid.raster(img)
```

\newpage

The components are as follows, and depicted in Figure 26:

*  bash/Unix - The entire procedure is handled by a bash shell script, executing other scripts or programs.
*  C/C++ - Initial analysis was completed in R, however, for greater efficiency, some data preprocessing, including merging and transformations were programmed in C/C++.
*  R - Most statistical computations and configuration file generations were done using many R libraries and programmed in R scripts.

\clearpage

# Statistical Measures and Features  

Regardless of the predictive method or technique chosen, the predictive accuracy and performance of any model is influenced by the features selected, and is therefore important to take into consideration. Feature selection is the reduction of the input variables. Whether it be in the field of statistics, data mining, or machine learning, massive amounts of data that are handled can greatly benefit from the careful selection of relevant features. In addition, removing redundancies also improves the efficiency and having both allows for further increased accuracy and reduction in complexity. However, there should be an appropriate selection of features so as to prevent any loss of information.[[@Guyon2003; @Yu2004]]

Depending on the size of the dataset and the number of features, or variables, the selection process may simply be done by a domain expert who has been trained in a particular field and has the expertise to determine which features are deemed as important. Although this may be sufficient in some cases, enormous amounts of data and variables make the process more complex, and less effective and efficient. More sophisticated methods go through a learning process in order to detect patterns with less human intervention.

An example of applying feature selection is in the area of text mining where unstructured data can be comprised of millions of words. Using such techniques as stop word elimination and stemming, the dimensionality is notably reduced. Principal component analysis is another statistical procedure by which the data can be transformed and represented as its eigenvalues and eigenvectors.

Network based intrusion detection has been studied for some time and can be implemented by using conventional network variables.[[@Ma2008; @Marchette2004]] In [[@Mantere2012; @Mantere2013]], the challenges of feature selection in the context of anomaly detection in industrial systems are discussed.

The first version of the SCAD\@COPS network intrusion detection device for industrial systems will be based on simple statistical variables that have been chosen by an expert in the domain of cyber security with experience in SCADA systems. Example configuration files generated from the statistical process as outlined in Section 9.2.2 (Appendix G) have been used as the parameters in the proof of concept.

\clearpage

# Testing and Evaluation  

Security agents supervise SCADA systems that have numerous controls and systems to oversee, therefore the great amount of data that is presented by the HMIs and monitoring systems can become overwhelming. In this regard, it is important to have pertinent data and  information alerted to the security agent. An effective NIDS should be able to monitor traffic and detect with a minimum amount of error any deviant behaviour or characteristics that occur out of the ordinary. Such events may be malicious as those seen in Chapter 4, as well as routine, or spontaneous, maintenance activities.

As discussed in Section 9.2.1, the process flow depicts the phases of the processes involved, from data acquisition, to data processing and statistical analysis, and finally to placing the device in “operational” mode where network traffic may be exposed to attacks. During the testing phase, another simulation was done with attacks injected via Metasploit. 

The test simulation exposed the routine activity running on the Virtual Scada Box to a remote MODBUS STOP attack. Metasploit provides a means for the attacker to end a PLC process control by sending MODBUS frames with function code 90 (0x5a). This is used to perform administrative commands without authentication thereby modifying the state of the PLC between STOP and RUN. Multiple frames are sent to the PLC in order to set it to INIT mode, and the following frames are sent to request a STOP (Appendix H):

```
5a 01 41 ff 00
00 5a 01 04
```

The packet capture file was also processed in a similar manner as the initial PCAP file, and then a comparison was made to find differences and anomalies between the two data sets.

The following tables list anomalies and differences detected in the attack simulation:

```{r, message=FALSE, warning=FALSE, echo=FALSE}
# normal simulation
load(paste(homeDir, "normal.Rda", sep=''))

# Sources
srcs  <- unique(normalModbusDT, by=c("ip.src"))[,.(ip.src)]

# Destinations
dst <- unique(normalModbusDT, by=c("ip.dst"))[,.(ip.dst)]

# Destination / UnitID
du <- unique(normalModbusDT,
             by=c("ip.dst",
                  "mbtcp.modbus.unit_id"))[
                    ,.(IP_DST_MODBUS_UNIT_ID = paste(ip.dst,
                                                     mbtcp.modbus.unit_id, sep="/"),
                       ip.dst,
                       mbtcp.modbus.unit_id)]

# Source / MAC Address
smac <- unique(normalModbusDT,
               by=c("ip.src", "eth.src"))[
                 ,.(IP_SRC_MAC_ADDR = paste(ip.src, eth.src, sep="/"),
                    ip.src,
                    eth.src)]


# Source / Function Code
sfunc <- normalModbusDT[,.(IP_SRC_MOD_FUNC = paste(ip.src, mbtcp.modbus.func_code, sep="/"))
                     , by=.(ip.src, mbtcp.modbus.func_code)][
                       ,.(IP_SRC_MOD_FUNC, ip.src,
                          mbtcp.modbus.func_code)]

reqs <- normalModbusDT[mbtcp.modbus.reference_num != '']
resp <- normalModbusDT[is.na(mbtcp.modbus.reference_num)]

# Source / Function Code

sfuncRef <- reqs[,.(IP_SRC_MOD_FUNC_REF = paste(ip.src, mbtcp.modbus.func_code,
                                                mbtcp.modbus.reference_num, sep="/"))
                 , by=.(ip.src, mbtcp.modbus.func_code, mbtcp.modbus.reference_num)][
                   ,.(IP_SRC_MOD_FUNC_REF,
                      ip.src,
                      mbtcp.modbus.func_code,
                      mbtcp.modbus.reference_num)][order(mbtcp.modbus.reference_num)]

# Average frequency of packets per second
avgPkt <- normalModbusDT[,.(frequency=.N),by=frame.second][,mean(frequency)]

# Frequency per second, per source/edst ip and function code
srcFuncFreq <- normalModbusDT[,.(frequency=.N),
                           by =.(ip.src, ip.dst, mbtcp.modbus.func_code,
                                 frame.second)][
                                   order(ip.src, ip.dst, mbtcp.modbus.func_code,
                                         frame.second)][,.(avgFrequencySec=mean(frequency)),
                                                        by=.(ip.src, ip.dst, mbtcp.modbus.func_code)]

# Frequency per second, per source/dest ip, function code, and reference num
srcFuncRefFreq <- reqs[,.(frequency=.N),
                       by =.(ip.src, ip.dst, mbtcp.modbus.func_code, mbtcp.modbus.reference_num,
                             frame.second)][
                               order(ip.src, ip.dst, mbtcp.modbus.func_code, mbtcp.modbus.reference_num,
                                     frame.second)][,.(avgFrequncySec=mean(frequency)),
                                                    by=.(ip.src, ip.dst, mbtcp.modbus.func_code,
                                                         mbtcp.modbus.reference_num)]


## attack simulation

load(paste(homeDir, "attack.Rda", sep=''))

attackSrcs  <- unique(attackModbusDT, by=c("ip.src"))[,.(ip.src)]

attackDst <- unique(attackModbusDT, by=c("ip.dst"))[,.(ip.dst)]

attackDu <- unique(attackModbusDT,
             by=c("ip.dst",
                  "mbtcp.modbus.unit_id"))[
                    ,.(IP_DST_MODBUS_UNIT_ID = paste(ip.dst,
                                                     mbtcp.modbus.unit_id, sep="/"),
                       ip.dst,
                       mbtcp.modbus.unit_id)]

attackSmac <- unique(attackModbusDT,
               by=c("ip.src", "eth.src"))[
                 ,.(IP_SRC_MAC_ADDR = paste(ip.src, eth.src, sep="/"),
                    ip.src,
                    eth.src)]

attackSfunc <- attackModbusDT[,.(IP_SRC_MOD_FUNC = paste(ip.src, mbtcp.modbus.func_code, sep="/"))
                     , by=.(ip.src, mbtcp.modbus.func_code)][
                       ,.(IP_SRC_MOD_FUNC, ip.src,
                          mbtcp.modbus.func_code)]

attackReqs <- attackModbusDT[mbtcp.modbus.reference_num != '']
attackResp <- attackModbusDT[is.na(mbtcp.modbus.reference_num)]

attackSfuncRef <- attackReqs[,.(IP_SRC_MOD_FUNC_REF = paste(ip.src, mbtcp.modbus.func_code,
                                                mbtcp.modbus.reference_num, sep="/"))
                 , by=.(ip.src, mbtcp.modbus.func_code, mbtcp.modbus.reference_num)][
                   ,.(IP_SRC_MOD_FUNC_REF,
                      ip.src,
                      mbtcp.modbus.func_code,
                      mbtcp.modbus.reference_num)][order(mbtcp.modbus.reference_num)]

attackAvgPkt <- attackModbusDT[,.(frequency=.N),by=frame.second][,mean(frequency)]

# Frequency per second, per source/dest ip and function code
attackSrcFuncFreq <- attackModbusDT[,.(frequency=.N),
                           by =.(ip.src, ip.dst, mbtcp.modbus.func_code,
                                 frame.second)][
                                   order(ip.src, ip.dst, mbtcp.modbus.func_code,
                                         frame.second)][,.(avgFrequencySec=mean(frequency)),
                                                        by=.(ip.src, ip.dst, mbtcp.modbus.func_code)]

# Frequency per second, per source/dest ip, function code, and reference num
attackSrcFuncRefFreq <- attackReqs[,.(frequency=.N),
                       by =.(ip.src, ip.dst, mbtcp.modbus.func_code, mbtcp.modbus.reference_num,
                             frame.second)][
                               order(ip.src, ip.dst, mbtcp.modbus.func_code, mbtcp.modbus.reference_num,
                                     frame.second)][,.(avgFrequncySec=mean(frequency)),
                                                    by=.(ip.src, ip.dst, mbtcp.modbus.func_code,
                                                         mbtcp.modbus.reference_num)]

setkey(attackSrcs, ip.src)
kable(attackSrcs[!srcs], caption='Anomalous Sources')

setkey(attackDst, ip.dst)
kable(attackDst[!dst], caption='Anomalous Destinations')

setkey(attackDu, IP_DST_MODBUS_UNIT_ID)
kable(attackDu[!du], caption='Anomalous Source / MODBUS Unit Pairs')

setkey(attackSmac, IP_SRC_MAC_ADDR)
kable(attackSmac[!smac], caption='Anomalous Source / MAC Address Pairs')
```

In Table 12, we see MODBUS function code 90, which is ordinarily sent to perform administrative commands without authentication.

```{r, echo=FALSE, warning=FALSE, message=FALSE, comment=''}
setkey(attackSfunc, IP_SRC_MOD_FUNC)
kable(attackSfunc[!sfunc], caption='Anomalous Source / MODBUS Function Code Pairs')
```

The difference in average frequency shown in Table 13 and 15 are indicated by a prefix 'n' for normal and 'a' for attack.

```{r, echo=FALSE, warning=FALSE, message=FALSE, comment=''}
mergedSrcFuncFreq <- merge(srcFuncFreq,attackSrcFuncFreq, 
                           by=c("ip.src","ip.dst","mbtcp.modbus.func_code"),
                           suffixes=c(".n", ".a"))
mergedSrcFuncFreq$avgFrequencySec.diff <- mergedSrcFuncFreq$avgFrequencySec.n - mergedSrcFuncFreq$avgFrequencySec.a
m1 <- mergedSrcFuncFreq[,.(ip.src,ip.dst, mbtcp.modbus.func_code)]
kable(m1, caption='Differences in Frequency of Source/Function Code')
m2 <- mergedSrcFuncFreq[,.(avgFrequencySec.n, avgFrequencySec.a, avgFrequencySec.diff)]
kable(m2)

mergedSrcFuncRefFreq <- merge(srcFuncRefFreq,attackSrcFuncRefFreq, 
                              by=c("ip.src","ip.dst","mbtcp.modbus.func_code","mbtcp.modbus.reference_num"),
                              suffixes=c(".n", ".a"))
mergedSrcFuncRefFreq$avgFrequencySec.diff <- mergedSrcFuncRefFreq$avgFrequncySec.n - mergedSrcFuncRefFreq$avgFrequncySec.a
m3 <- mergedSrcFuncRefFreq[,.(ip.src, ip.dst, mbtcp.modbus.func_code, mbtcp.modbus.reference_num)]
kable(m3, caption='Differences in Frequency of Source/Function Code/Reference Number')
m4 <- mergedSrcFuncRefFreq[,.(avgFrequncySec.n, avgFrequncySec.a, avgFrequencySec.diff)]
kable(m4)

```

\clearpage

# Conclusion and Future Work  

The goal of this project was to provide the study, analysis and conception of a proof of concept for a hybrid NIDS, focusing on the anomaly based detection component. The work realized during this project began with a study of the domain and the state of the art of network intrusion detection systems in industrial control systems, SCADA systems in particular. SCADA systems have typically been isolated and less prone to cyber threats, but as they continue to increasingly use traditional IT infrastructure in order to minimize costs and increase efficiency and functionality, they become more and more vulnerable to cyber attacks. A quality of ICSs is that their topology tends to remain static, their protocols simple, and the traffic fairly regular. 

Following the overviews of the SCADA systems and networking principles, the MODBUS protocol and intrusion detection systems were presented, as well as a few common attacks on SCADA systems were discussed. IDSs are implemented as either host- or network-based and they offer a solution to provide supervision and monitoring of SCADA systems in order to alert to suspicious or anomalous activity. Most commercial IDSs offered are usually signature-based, which are only able to detect previously identified threats and defined rules of behavior. Then, different techniques of anomaly based network intrusion detection were described. With a growing need for robust and flexible detection of new threats as the number of attacks increase, there is more research and advancements in anomaly detection applying methods such as statistical, data mining and machine learning techniques to find intelligent ways of anomaly detection. 


SCAD\@COPS is a proof of concept presented by diateam, which is a hybrid IDS that incorporates both a signature-based, as well as an anomaly-based IDS. After having completed a comprehensive study of intrusion detection systems and its application in SCADA systems, the first step carried out in the development of the POC was the exploratory data analysis of the “normal” network traffic data simulated by the Virtual Scada Box. In addition to the traditional methods of using descriptive statistics to explain the data, the various graphical and visual manners of representing the data were exhibited. An initial implementation of the data acquisition, data processing and statistical computation were then executed using various tools. The project was concluded by running another simulation in “attack” mode and running a comparison against the normal data in order to detect the anomalies.

Although the first implementation of the SCAD\@COPS NIDS prototype uses rather simple statistical analysis and methods, additional research and work can be conducted to devise further viable and effective methods for anomaly detection. Other areas of study include more sophisticated and advanced detection of anomalous behaviour applying machine learning, or data mining techniques such as Neural and Bayesian networks. Additionally, another potential area of study is Time-Series analysis. As these methods are fairly new to the field, more work can be explored and these methods can be exploited to further improve the accuracy and detection of network intrusion in future versions of SCAD\@COPS.

\clearpage

# Appendix A {-}

## MODBUS Function Codes[^4]
[^4]: https://en.wikipedia.org/wiki/Modbus

```{r, echo=FALSE, fig.pos='middle', fig.align='center'}
img <- readPNG(paste(homeDir, "imgs/modbusFuncCodes.png", sep=''))
grid.raster(img)
```

\clearpage

# Appendix B {-}

## Wireshark Exports {-}

Using the export facility in Wireshark, the following are a description of the exported files:

Entire pcap file exported in CSV format:  

 SCADA_20150429_042915.csv  
 -------------------------
 Time   
 Source   
 Destination   
 Protocol   
 Length   
 Info                                             

List of endpoints, the traffic to and from an IP address:  

 SCADA_Security_042915_TCP_Endpoints.csv
 --------------------------------------
 Address   
 Port   
 Packets   
 Bytes  
 Tx.Packets   
 Tx.Bytes    
 Rx.Packets   
 Rx.Bytes   
 Latitude   
 Longitude


List of conversations, the traffic between two endpoints :  

 SCADA_Security_042915_TCP_Conversations.csv
 -----------------
 Address.A   
 Port.A    
 Address.B   
 Port.B    
 Packets  
 Bytes  
 Packets.A.B   
 Bytes.A.B   
 Packets.A.B.1   
 Bytes.A.B.1  
 Rel.Start   
 Duration   
 bps.A.B    
 bps.A.B.1   
 
\clearpage

# Appendix C {-}

## MODBUS/TCP Request/Response Packet Statistics {-}

```{r, comment='', warning=FALSE, echo=FALSE, message=FALSE}
#summary(requests)
req1<-summary(requests[,.(frame.number, frame.time_relative, frame.time_delta, frame.len, ip.proto, ip.version)])
req2<-summary(requests[,.(ip.src, eth.src, ip.dst, eth.dst)])
req3<-summary(requests[,.(mbtcp.modbus.unit_id, tcp.srcport, tcp.dstport, mbtcp.prot_id, mbtcp.trans_id)])
req4<-summary(requests[,.(mbtcp.modbus.func_code, mbtcp.modbus.reference_num, mbtcp.modbus.word_cnt)])
req5<-summary(requests[,.(mbtcp.len, mbtcp.modbus.data, frame.second)])

kable(req1, caption="Requests Summary")
kable(req2)
kable(req3)
kable(req4)
kable(req5)
```

\newpage

```{r, comment='', warning=FALSE, echo=FALSE, message=FALSE}
#summary(responses)
rep1<-summary(responses[,.(frame.number, frame.time_relative, frame.time_delta, frame.len, ip.proto, ip.version)])
rep2<-summary(responses[,.(ip.src, eth.src, ip.dst, eth.dst)])
rep3<-summary(responses[,.(mbtcp.modbus.unit_id, tcp.srcport, tcp.dstport, mbtcp.prot_id, mbtcp.trans_id)])
rep4<-summary(responses[,.(mbtcp.modbus.func_code, mbtcp.modbus.reference_num, mbtcp.modbus.word_cnt)])
rep5<-summary(responses[,.(mbtcp.len, mbtcp.modbus.data, frame.second)])

kable(rep1, caption="Responses Summary")
kable(rep2)
kable(rep3)
kable(rep4)
kable(rep5)

rm(responses, requests)
```

\clearpage

# Appendix D {-}

## Merged Request/Response Packet Statistics {-}

```{r, comment='', warning=FALSE, echo=FALSE, message=FALSE}
#summary(mergedSewDT)
rep1<-summary(mergedSewDT[,.(frame.number, frame.time_relative, frame.time_delta, frame.len)])
rep2<-summary(mergedSewDT[,.(ip.src, eth.src, ip.dst, eth.dst)])
rep3<-summary(mergedSewDT[,.(mbtcp.modbus.unit_id, tcp.srcport, tcp.dstport)])
rep4<-summary(mergedSewDT[,.(mbtcp.prot_id, mbtcp.trans_id, mbtcp.len, mbtcp.modbus.func_code)])
rep5<-summary(mergedSewDT[,.(mbtcp.modbus.word_cnt, frame.second, mbtcp.modbus.reference_num)])

kable(rep1, caption="Merged Packets Summary")
kable(rep2)
kable(rep3)
kable(rep4)
kable(rep5)

rm(mergedSewDT)
```

\newpage

# Appendix E {-}

## Wireshark[^5] - Network Traffic Analysis Tool
[^5]: https://www.wireshark.org/docs/wsug_html_chunked

Developed in 1997 by Gerald Combs originally named Ethereal, Wireshark is now an Open Source GNU project. It is a network packet analyzer, or “packet sniffer”, that captures and displays network packets.

Captured network packets are saved in the pcap file format and can be dissected and parsed by Wireshark in order to analyze its contents.  An important aspect of Wireshark is that of its passive/monitoring nature and so does not send, manipulate, or modify the data passing over the network.

## TShark[^6]
[^6]: https://www.wireshark.org/docs/man-pages/tshark.html

Another tool from the Wireshark suite is the command-line tool similar to tcpdump[^7] is tshark, a network protocol analyzer. In addition to capturing packet data over a live network, it is also capable of analyzing packets from an existing capture file.

[^7]: http://www.tcpdump.org

## UNIX Utilities
There are a myriad of UNIX utilities that are used for administration, scripting, text processing, etc.[[@Troy1990]] In the data parsing and transformation process, the UNIX tools employedused were bash, sed, and, awk, which supports the use of regular expressions.

## R - Statistical Tool[^8]
[^8]: http://www.r-project.org

R is an Open Source programming language and environment used for statistical computing and graphics. Initially developed by John Chambers at Bell Labs as the S language in 1993, R was created as a freely available version under the GNU project by  Ross Ihaka and Robert Gentleman at the University of Auckland, New Zealand.

Maintained by the R Development Core Team and with an active and growing community, it provides various statistical and graphical creation capabilities available under most operating systems, and is extensible with numerous packages available. Its major limitation is that there must be sufficient RAM to hold the data in memory.

RStudio[^9]  is an integrated development environment for the R statistical programming language.

[^9]: https://www.rstudio.com

## C/C++

Originally developed by Dennis Ritchie at AT&T Bell Labs in the late 60s and early 70s, the C programming language is a low-level, general purpose computer programming language, that was  initially designed for and implemented on the UNIX OS. A sucessor to the C programming language is C++, developed by Bjarne Stroustrup in the early 80s. It inherits most of C’s syntax, as well as adds abstraction lending itself to be an object-oriented language.[[@Stroustrup2000]]

## Suricata[^10]
[^10]: http://www.suricata-ids.org

A widely used network intrusion detection system is Snort.[^11] It is open source, and although highly effective and proven, its limitation is that it is single-threaded. A newer generation NIDS that has grown fairly popular is Suricata, developed by the Open Information Security Foundation (OISF) and partly funded by the US Department Homeland Security’s Directorate for Science and Technology. 

Suricata is a high performing NIDS, IPS, and network security monitoring engine, that is based on signatures, however, unlike Snort it has a multithreaded architecture. The advanced techniques embedded in the engine uses an HTTP normalizer and parser in order to process HTTP streams which allow it to comprehend traffic at the application layer of the OSI model.

[^11]: http://www.snort.org

## Metasploit[^12]

[^12]: http://www.metasploit.com/index.jsp

The open source network security tool was Metsaploit, created in 2003 by H.D.Moore, that is used to test weaknesses in computer systems, including breaking into systems that are remote. In addition to legitimate activities, Metasploit can be utilized to take unauthorized actions. One of its major advantages as a modular framework is that it allows for combinations of any exploit with any payload, allowing it to simulate real-world attacks.

\newpage

# Appendix F {-}

## Commands and Scripts {-}

#### Bash scripts {-}

*  processScada.sh - Driver script for statistical computational process.
*  sew.sh - Script to execute extract data from PCAP file via Tshark command

#### C/C++ script {-}

*  processMerge.cpp - C/C++ component for handling merge of MODBUS packets in data 
processing.

#### R {-}

*  install.R - Setup script to install required packages.
*  sewModbus.R - Script to process normal state packet capture file.
*  modbus.Rmd - Script for processing, analysing and visualizing modbus data.
*  attack.R - Script to process attack state packet capture file.

\newpage

# Appendix G {-}

## Configuration Files {-}

Configuration files generated from statistical processing.

### whitelist.db {-}

~~~~~~
{
"IP_SRC" : ["192.168.12.117","192.168.12.252"],
"IP_DST" : ["192.168.12.252","192.168.12.117"],
"IP_MODBUS_UNIT_ID" : [
  "192.168.12.252/1" : {
   "IP_ADDR" : "192.168.12.252",
   "UNIT_ID" : "1 "
  },
  "192.168.12.117/1" : {
   "IP_ADDR" : "192.168.12.117",
   "UNIT_ID" : "1 "
  }
],
"IP_ADDR_MAC_ADDR" : [
  "192.168.12.117/08:00:27:f9:b1:f1" : {
    "IP_ADDR" : "192.168.12.117",
   "MAC_ADDR" : "08:00:27:f9:b1:f1 "
  },
  "192.168.12.252/00:0f:69:0d:55:cd" : {
    "IP_ADDR" : "192.168.12.252",
   "MAC_ADDR" : "00:0f:69:0d:55:cd "
  }
],
"IP_ADDR_MODBUS_FUNC" : [
  "192.168.12.117/4" : {
    "IP_ADDR" : "192.168.12.117",
   "MODBUS_FUNCTION" : "4 "
  },
  "192.168.12.252/4" : {
    "IP_ADDR" : "192.168.12.252",
   "MODBUS_FUNCTION" : "4 "
  }
],
"IP_ADDR_MODBUS_FUNC_REF" : [
  "192.168.12.117/4/0" : {
    "IP_SRC" : "192.168.12.117",
     "MODBUS_FUNCTION" : "4 ",
    "MODBUS_REFERENCE" : "0 "
  },
  "192.168.12.117/4/1" : {
    "IP_SRC" : "192.168.12.117",
     "MODBUS_FUNCTION" : "4 ",
    "MODBUS_REFERENCE" : "1 "
  },
  "192.168.12.117/4/2" : {
    "IP_SRC" : "192.168.12.117",
     "MODBUS_FUNCTION" : "4 ",
    "MODBUS_REFERENCE" : "2 "
  },
  "192.168.12.117/4/3" : {
    "IP_SRC" : "192.168.12.117",
     "MODBUS_FUNCTION" : "4 ",
    "MODBUS_REFERENCE" : "3 "
  }
]
}
~~~~~~

\newpage

### stats.db {-}

~~~~~~
{
"SOURCE_DEST_FUNCTION_FREQUENCY" : [
  "192.168.12.117/192.168.12.252/4" : {
    "IP_SRC" : "192.168.12.117",
    "IP_DST" : "192.168.12.252",
    "MODBUS_FUNCTION" : "4 ",
    "FREQUENCY" : "33.170213 "
  }
],
"SOURCE_DEST_FUNCTION_REFERENCE_FREQUENCY" : [
  "192.168.12.117/192.168.12.252/4/0" : {
    "IP_SRC" : "192.168.12.117",
    "IP_DST" : "192.168.12.252",
    "MODBUS_FUNCTION" : "4 ",
    "MODBUS_REFERENCE" : "0 ",
    "FREQUENCY" : "13.715621 "
  },
  "192.168.12.117/192.168.12.252/4/1" : {
    "IP_SRC" : "192.168.12.117",
    "IP_DST" : "192.168.12.252",
    "MODBUS_FUNCTION" : "4 ",
    "MODBUS_REFERENCE" : "1 ",
    "FREQUENCY" : "15.649333 "
  },
  "192.168.12.117/192.168.12.252/4/2" : {
    "IP_SRC" : "192.168.12.117",
    "IP_DST" : "192.168.12.252",
    "MODBUS_FUNCTION" : "4 ",
    "MODBUS_REFERENCE" : "2 ",
    "FREQUENCY" : "1.961230 "
  },
  "192.168.12.117/192.168.12.252/4/3" : {
    "IP_SRC" : "192.168.12.117",
    "IP_DST" : "192.168.12.252",
    "MODBUS_FUNCTION" : "4 ",
    "MODBUS_REFERENCE" : "3 ",
    "FREQUENCY" : "1.971774 "
  }
],
"MODBUS_FUNCTION_REFERENCE_DATA_STATS" : [
  "4/0" : {
    "MODBUS_FUNCTION" : "4",
    "MODBUS_REFERENCE" : "0",
    "D_MIN" : "112.00 ",
    "D_MEAN" : "112.00 ",
    "D_STD_DEV" : "0.00 ",
    "D_MAX" : "112.00 "
  },
  "4/1" : {
    "MODBUS_FUNCTION" : "4",
    "MODBUS_REFERENCE" : "1",
    "D_MIN" : "64.00 ",
    "D_MEAN" : "81.31 ",
    "D_STD_DEV" : "3.89 ",
    "D_MAX" : "84.00 "
  },
  "4/2" : {
    "MODBUS_FUNCTION" : "4",
    "MODBUS_REFERENCE" : "2",
    "D_MIN" : "4758.00 ",
    "D_MEAN" : "5005.44 ",
    "D_STD_DEV" : "179.37 ",
    "D_MAX" : "5242.00 "
  },
  "4/3" : {
    "MODBUS_FUNCTION" : "4",
    "MODBUS_REFERENCE" : "3",
    "D_MIN" : "0.00 ",
    "D_MEAN" : "3392.65 ",
    "D_STD_DEV" : "2074.52 ",
    "D_MAX" : "6890.00 "
  }
]
}
~~~~~~

\newpage

# Appendix H {-}

## Metasploit Attack {-}

The Metasploit Framework is comprised of various modules. In the test attack case, the modicon_command module was used.

The frames sent in order to set the PLC to one of the following states:

INIT
```
00 5a 00 02
00 5a 00 01 00
00 5a 00 0a 00 + T' * 0xf9
00 5a 00 03 00
00 5a 00 03 04
00 5a 00 04
00 5a 00 01 00
00 5a 00 0a 00
00 5a 00 04
00 5a 00 04
00 5a 00 20 00 13 00 00 00 00 00 64 00
00 5a 00 20 00 13 00 64 00 00 00 9c 00
00 5a 00 20 00 14 00 00 00 00 00 64 00
00 5a 00 20 00 14 00 64 00 00 00 f6 00
00 5a 00 20 00 14 00 5a 01 00 00 f6 00
00 5a 00 20 00 14 00 5a 02 00 00 f6 00
00 5a 00 20 00 14 00 46 03 00 00 f6 00
00 5a 00 20 00 14 00 3c 04 00 00 f6 00
00 5a 00 20 00 14 00 32 05 00 00 f6 00
00 5a 00 20 00 14 00 28 06 00 00 0c 00
00 5a 00 20 00 13 00 00 00 00 00 64 00
00 5a 00 20 00 13 00 64 00 00 00 9c 00
00 5a 00 10 43 4c 00 00 0f
USER-714E74F21B
META-SPLOITMETA
00 5a 01 04
00 5a 01 50 15 00 01 0b
00 5a 01 50 15 00 01 07
00 5a 01 12
00 5a 01 04
00 5a 01 12
00 5a 01 04
00 5a 00 02
00 5a 00 58 01 00 00 00 00 ff ff 00 70
00 5a 00 58 07 01 80 00 00 00 00 fb 00
00 5a 01 04
00 5a 00 58 07 01 80 00 00 00 00 fb 00
```

STOP
```
00 5a 01 41 ff 00
00 5a 01 04
```

START
```
00 5a 01 40 ff 00
00 5a 01 04
```

\newpage
  
# Bibliography {-}

